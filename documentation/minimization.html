<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>minimization API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>minimization</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="minimization.minimize_scalar"><code class="name flex">
<span>def <span class="ident">minimize_scalar</span></span>(<span>f, xmin, xmax, xinit=None, method='goldenSearch', tol=1e-06, gtol=1e-06, maxIter=500, gf=None, constraints=[], penalityFactor=100, returnDict=False, storeIterValues=False, deriveMethod='finite-difference', dh=1e-09, stop_tolRatio=0.01, stop_gtolRatio=0.01, precallfunc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>minimize_scalar : </p>
<p>Algorithmes de minimisation de fonctions scalaires à une variable.</p>
<p>Parameters : </p>
<pre><code>- f (callable) : une fonction scalaire d'une variable scalaire réelle.

- xmin (float) : borne inférieure du problème de minimisation.

- xmax (float) : borne supérieure du problème de minimisation.

- xinit (float or None) option : point initiale uniquement pour les
    méthodes [scalarGradient], si None xinit = (xmin+xmax)/2.

- method (str) option : méthode de minimisation. 
    *"goldenSearch" : méthode dichotomique basée sur le nombre d'or sans
        évaluation du gradient. 
    *"scalarGradient" : méthode du gradient appliqué en dimension 
        scalaire. Gradient approché ou exacte.

- tol (float) option : tolérance sur critère d'arrêt. L'agorithme 
    s'arrête si (residu &lt; tol)AND(gradient&lt;gtol).

- gtol (float) option : tolérance sur la valeur du gradient.

- maxIter (int) option : nombre limite d'itérations.

- gf (callable or None) : fonction de la dérivée. Fonction scalaire 
    réelle. Si 'None' une approximation est utilisée.

- constraints (List of dict) option : 
        Definition des contraintes dans une liste de dictionnaires. 
            Chaque dictionnaire contient les champs suivants

            type : str
                Contraintes de type egalite 'eq' ou inegalite 'ineq' ; 
            fun : callable
                La fonction contrainte de la meme forme que func ; 
            jac : callable 
                Dérivée de la fonction contrainte de la même forme
                    que gf ;

- penalityFactor (float) option : facteur de penalisation. 
    La nouvelle fonction objectif est evaluee par la forme suivante :
    penal_objective = objective_func +
                      sum(ci**2 if ci not feasible)*penalityFactor

- returnDict (bool) option : 
        Si l'option est True alors l'algorithme retourne un dictionnaire.

- storeIterValues (bool) option :
        L'évolution des variables durant la résolution est stockée dans 
        un numpy array retourné dans le dictionnaire si 
        returnDict = True ;

- deriveMethod (string) option : méthode d'approximation de la derivée. 
        *"finite-difference" : df = ( f(x+dh)-f(x) )/dh
        *"complex" : df = imag(f(x+1j*dh)/dh))

- dh (float) option : pas d'approximation de la dérivée.

- stop_tolRatio (float) option : tolerance minimale pour forcer l'arrêt 
        sur le résidu si le gradient n'atteint pas la tolerance gtol. 
        mintol = tol*stop_tolRatio.

- stop_gtolRatio (float) option : tolerance minimale pour forcer l'arrêt 
        sur le gradient si le résidu n'atteint pas la tolerance tol. 
        mingtol = gtol*stop_gtolRatio.

- precallfunc (callable or None) option : 
        Definition d'une fonction sans renvoie de valeur à executer 
        avant chaque evaluation de la fonction objectif, des gradients
         ou des contraintes.
</code></pre>
<p>Returns : </p>
<pre><code>Si (returnDict = False) : 
    x (float) : solution de l'algorithme d'optimisation.

Si (returnDict = False) : 
    dict :
        "method" : algorithme utilisé.
        "success" : True si l'agorithm a convergé correctement.
        "x": solution.
        "fmin": valeur de la fonction objectif.
        "residual": résidu.
        "gradResidual": résidu du gradient.
        "gradNorm": norme du gradient.
        "constrViolation": list des violations des contraintes. 
                           Vide si pas de contrainte.
        "iterations": nombre d'itérations.
        "functionCalls": nombre d'appels de la fonction.
        "gradientCalls": nombre d'appels du gradient.

        Si (storeIterValues = True) : 
            "xHistory" : array des variables de recherche. 
            "fHistory" : array des valeurs de la fonction objectif. 
            "rHistory" : array des valeurs du résidu.
</code></pre>
<p>Example : </p>
<pre><code>import numpy as np

xmin,xmax = 2.7,7.5
xinit = (xmax+xmin)/2

f = lambda x : np.sin(x)*x + np.sin(10/3*x)
df = lambda x : np.cos(x)*x + np.sin(x) + 10/3*np.cos(10/3*x)
x = np.linspace(xmin,xmax,250)
y = f(x)

dictgold = minimize_scalar(f,xmin,xmax,returnDict=True,
                            method="goldenSearch")

dictgrad = minimize_scalar(f,xmin,xmax,
                        xinit=xinit,
                        returnDict=True,
                        gf=df,
                        method="scalarGradient")

Outputs : 
    #Solution goldenSearch
    method  :  goldenSearch
    success  :  True
    x  :  5.094751312571761
    fmin  :  -5.6832744082498365
    constrViolation  :  []
    residual  :  8.696778973964855e-07
    iterations  :  29
    functionCalls  :  32
    gradientCalls  :  0

    #Solution scalarGradient
    method  :  gradient
    success  :  True
    x  :  5.094751436644642
    fmin  :  -5.683274408249959
    residual  :  2.6531499293843317e-06
    gradResidual  :  1.8482260166763353e-09
    gradNorm  :  1.8482260166763353e-09
    constrViolation  :  []
    iterations  :  2
    functionCalls  :  7
    gradientCalls  :  3
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="minimization.realBiObjective_NSGA2"><code class="flex name class">
<span>class <span class="ident">realBiObjective_NSGA2</span></span>
<span>(</span><span>func1, func2, xmin, xmax, constraints=[], preprocess_function=None, func1_criterion='min', func2_criterion='min', mutation_method='polynomial', mutation_rate=0.1, mutation_step=0.1, crossover_method='SBX', eta_cross=1.0, sharing_distance=None, eqcons_atol=0.1, penalityFactor=1000.0, constraintMethod='feasibility', init='LHS')</span>
</code></dt>
<dd>
<div class="desc"><p>continousBiObjective_NSGA : </p>
<p>Algorithme genetique d'optimisation bi-objectif à variables reelles.
Recherche du front de Pareto de fonctions scalaires à variables
continues sur l'intervalle [xmin;xmax].</p>
<hr>
<p>Source :
A Fast and Elitist Multiobjective Genetic Algorithm : NSGA-II
Kalyanmoy Deb, Associate Member, IEEE, Amrit Pratap, Sameer Agarwal,
and T. Meyarivan
Parameters :
- func1 (callable) :
Fonction objectif a optimiser de la forme f(x) ou x est
l'argument de la fonction de forme scalaire ou array et
renvoie un scalaire ou array.
- func2 (callable) :
Fonction objectif a optimiser de la forme f(x) ou x est
l'argument de la fonction de forme scalaire ou array et
renvoie un scalaire ou array.
- xmin (array like) :
Borne inferieure des variables d'optimisation.
- xmax (array like) :
Borne supérieure des variables d'optimisation. Doit être de
même dimension que xmin.
- constraints (List of dict) option :
Definition des contraintes dans une liste de dictionnaires.
Chaque dictionnaire contient les champs suivants
type : str
Contraintes de type egalite 'eq' ou inegalite 'ineq' ;
fun : callable
La fonction contrainte de la meme forme que func ;
- preprocess_function (callable or None) option :
Definition d'une fonction sans renvoie de valeur à executer
avant chaque evaluation de la fonction objectif func ou
des contraintes.
- func1_criterion (string) option :
Definition du critere du premier objectif.
&gt;&gt;'min' = minimisation
&gt;&gt;'max' = maximisation
&gt;&gt; else : maximisation
- func2_criterion (string) option :
Definition du critere du deuxieme objectif.
&gt;&gt;'min' = minimisation
&gt;&gt;'max' = maximisation
&gt;&gt; else : maximisation
Example :
import numpy as np
xmin,xmax = [-2],[2]
x = np.linspace(xmin[0],xmax[0],150)
f1 = lambda x : (0.5<em>x</em><em>2+x)/4
f2 = lambda x : (0.5</em>x**2-x)/4
c = lambda x : np.sin(x)
cons = [{"type":'ineq','fun':c}]
nsga_instance = continousBiObjective_NSGA(f1,
f2,
xmin,
xmax,
constraints=cons,
func1_criterion='min',
func2_criterion='min')</p>
<pre><code>xfront,f1front,f2front = nsga_instance.optimize(20,100)
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_genetic_algorithm.genetic_operator</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="minimization.realBiObjective_NSGA2.define_initial_population"><code class="name flex">
<span>def <span class="ident">define_initial_population</span></span>(<span>self, xstart=None, selector='LHS')</span>
</code></dt>
<dd>
<div class="desc"><p>Definition d'une population initiale. </p>
<p>Parameter : </p>
<pre><code>- xstart (array(npop,ndof)) or None option : 
    xstart est la solution initiale. Ses dimensions doivent etre de
    (npop,ndof). 
    npop la taille de la population et ndof le nombre de variable
    (degrees of freedom).

- selector (string) option : 
    si pas de xstart definit, selection aléatoire : 
        'LHS' : Latin Hypercube Selector, variante meilleure que uniforme ; 
        'random' : loi uniforme ; 
        sinon 'LHS' ;
</code></pre></div>
</dd>
<dt id="minimization.realBiObjective_NSGA2.getConstraintViolation"><code class="name flex">
<span>def <span class="ident">getConstraintViolation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="minimization.realBiObjective_NSGA2.getLastPopulation"><code class="name flex">
<span>def <span class="ident">getLastPopulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="minimization.realBiObjective_NSGA2.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self, npop, ngen, nfront=None, verbose=False, returnDict=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Algorithme d'optimisation bi-objectifs sous contrainte.
Parameters :
- npop (int) :
Taille de la population. Si npop est impair, l'algorithm
l'augmente de 1. Usuellement pour un probleme sans contrainte
une population efficace est situee entre 5 et 20 fois le
nombre de variable. Si les contraintes sont fortes, il sera
utile d'augmenter la population. Ce parametre n'est pas pris
en compte si une population initiale a ete definie.
- ngen (int) :
Nombre de generation. Usuellement une bonne pratique est de
prendre 2 à 10 fois la taille de la population.
- nfront (int or None) option :
Nombre de point maximum dans le front de Pareto. Si None,
alors nfront = 3*npop
- verbose (bool) option :
Affiche l'etat de la recherche pour chaque iteration.
Peut ralentir l'execution.
- returnDict (bool) option :
Si l'option est True alors l'algorithme retourne un
dictionnaire. </p>
<p>Returns :
Si (returnDict = False) :
tuple : (
xsolutions, objective1_solutions,
objective2_solutions )
(array(ndof,nfront), array(nfront), array(nfront))</p>
<pre><code>        - xsolutions sont les solutions composants le front 
          de Pareto.
        - objective1_solutions sont les points de la fonction 1 
          dans le front de Pareto. 
        - objective2_solutions sont les points de la fonction 2 
          dans le front de Pareto.

Si (returnDict = True) : 
    dict :
        "method" (str) : algorithm utilise.
        "optimization" (str) : minimisation ou maximisation.
        "success" (bool) : True si l'algorithm a converge.
        "x" (array or None) : solutions du front de Pareto.
        "f1" (array or None) : front de Pareto f1.
        "f2" (array or None) : front de Pareto f2.
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="minimization.realSingleObjectiveGA"><code class="flex name class">
<span>class <span class="ident">realSingleObjectiveGA</span></span>
<span>(</span><span>func, xmin, xmax, constraints=[], preprocess_function=None, mutation_method='normal', mutation_rate=0.1, mutation_step=0.1, crossover_method='SBX', eta_cross=1.0, sharing_distance=None, atol=0.0, tol=0.001, stagThreshold=None, eqcons_atol=0.1, penalityFactor=1000.0, constraintMethod='penality', elitisme=True, elite_maxsize=None, init='LHS')</span>
</code></dt>
<dd>
<div class="desc"><p>Instance de continousSingleObjectiveGA : </p>
<p>Algorithme genetique d'optimisation de fonction mono-objectif à
variables reelles. Recherche d'un optimum global de la fonction f sur
les bornes xmin-xmax. </p>
<p>Parameters : </p>
<pre><code>- func (callable) : 
    Fonction objectif a optimiser de la forme f(x) ou x est 
    l'argument de la fonction de forme scalaire ou array et renvoie 
    un scalaire ou array.

- xmin (array like) : 
    Borne inferieure des variables d'optimisation.

- xmax (array like) : 
    Borne supérieure des variables d'optimisation. Doit être de 
    même dimension que xmin.

- constraints (List of dict) option : 
    Definition des contraintes dans une liste de dictionnaires. 
    Chaque dictionnaire contient les champs suivants 
        type : str
            Contraintes de type egalite 'eq' ou inegalite 'ineq' ; 
        fun : callable
            La fonction contrainte de la meme forme que func ;

- preprocess_function (callable or None) option : 
    Definition d'une fonction sans renvoie de valeur à executer 
    avant chaque evaluation de la fonction objectif func ou des 
    contraintes.
</code></pre>
<p>Example : </p>
<pre><code>func = lambda x : x[0]**2 + x[1]**2
xmin = [-1,-1]
xmax = [1,1]
ga_instance = continousSingleObjectiveGA(func,
                                        xmin,
                                        xmax)


resGA = ga_instance.minimize(20,100,verbose=False,returnDict=True)

Ouputs : 
    ############################################################

    AG iterations completed     
    Success :  True
    Number of generations :  100
    Population size :  20
    Elapsed time : 0.162 s
    ############################################################

    resGA = {
        method  :  Continous Single Objective Genetic Algorithm
        optimization  :  minimization
        success  :  True
        x  :  [-0.00222156  0.00380852] #may vary
        f  :  1.9440156259914855e-05    #may vary
        constrViolation  :  []
        }
</code></pre></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>_genetic_algorithm.genetic_operator</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="minimization.realSingleObjectiveGA.define_initial_population"><code class="name flex">
<span>def <span class="ident">define_initial_population</span></span>(<span>self, xstart=None, selector='LHS')</span>
</code></dt>
<dd>
<div class="desc"><p>Definition d'une population initiale. </p>
<p>Parameter : </p>
<pre><code>- xstart (array(npop,ndof)) or None option : 
    xstart est la solution initiale. Ses dimensions doivent etre de
    (npop,ndof). 
    npop la taille de la population et ndof le nombre de variable
    (degrees of freedom).

- selector (string) option : 
    si pas de xstart definit, selection aléatoire : 
        'LHS' : Latin Hypercube Selector, variante meilleure que uniforme ; 
        'random' : loi uniforme ; 
        sinon 'LHS' ;
</code></pre></div>
</dd>
<dt id="minimization.realSingleObjectiveGA.getLastPopulation"><code class="name flex">
<span>def <span class="ident">getLastPopulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="minimization.realSingleObjectiveGA.getStatOptimisation"><code class="name flex">
<span>def <span class="ident">getStatOptimisation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="minimization.realSingleObjectiveGA.maximize"><code class="name flex">
<span>def <span class="ident">maximize</span></span>(<span>self, npop, ngen, verbose=True, returnDict=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Algorithme de maximisation de la fonction objectif sous contrainte.</p>
<p>Parameters : </p>
<pre><code>- npop (int) : 
    Taille de la population. Si npop est impair, l'algorithm 
    l'augmente de 1. Usuellement pour un probleme sans contrainte 
    une population efficace est situee entre 5 et 20 fois le nombre 
    de variable. Si les contraintes sont fortes, il sera utile 
    d'augmenter la population. Ce parametre n'est pas pris en compte
    si une population initiale a ete definie.

- ngen (int) : 
    Nombre de generation. Usuellement une bonne pratique est de 
    prendre 2 à 10 fois la taille de la population.

- verbose (bool) option : 
    Affiche l'etat de la recherche pour chaque iteration. Peut 
    ralentir l'execution.

- returnDict (bool) option : 
    Si l'option est True alors l'algorithme retourne un 
    dictionnaire.
</code></pre>
<p>Returns : </p>
<pre><code>Si (returnDict = False) : 
    tuple : xsolution, objective_solution (array(ndof), array(1)) 
                ou (None, None)
        - xsolution est la meilleure solution x historisee. 
          Sa dimension correspond a ndof, la taille du probleme 
          initial.
        - objective_solution est la fonction objectif evaluee à 
          xsolution. 
        Si la solution n'a pas convergee et les contraintes jamais 
        validee, l'algorithme retourne (None, None)

Si (returnDict = False) : 
    dict :
        "method" (str) : algorithm utilise.
        "optimization" (str) : minimisation ou maximisation.
        "success" (bool) : True si l'algorithm a converge.
        "x" (array or None) : Solution ou None si success = False.
        "f" (array or None) : Maximum ou None si success = False.
</code></pre></div>
</dd>
<dt id="minimization.realSingleObjectiveGA.minimize"><code class="name flex">
<span>def <span class="ident">minimize</span></span>(<span>self, npop, ngen, verbose=True, returnDict=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Algorithme de minimisation de la fonction objectif sous contrainte.</p>
<p>Parameters : </p>
<pre><code>- npop (int) : 
    Taille de la population. Si npop est impair, l'algorithm 
    l'augmente de 1. Usuellement pour un probleme sans contrainte 
    une population efficace est situee entre 5 et 20 fois le nombre 
    de variable. Si les contraintes sont fortes, il sera utile 
    d'augmenter la population. Ce parametre n'est pas pris en compte
    si une population initiale a ete definie.

- ngen (int) : 
    Nombre de generation. Usuellement une bonne pratique est de 
    prendre 2 à 10 fois la taille de la population.

- verbose (bool) option : 
    Affiche l'etat de la recherche pour chaque iteration. Peut 
    ralentir l'execution.

- returnDict (bool) option : 
    Si l'option est True alors l'algorithme retourne un 
    dictionnaire.
</code></pre>
<p>Returns : </p>
<pre><code>Si (returnDict = False) : 
    tuple : xsolution, objective_solution (array(ndof), array(1)) 
                ou (None, None)
        - xsolution est la meilleure solution x historisee. 
          Sa dimension correspond a ndof, la taille du probleme 
          initial.
        - objective_solution est la fonction objectif evaluee à 
          xsolution. 
        Si la solution n'a pas convergee et les contraintes jamais 
        validee, l'algorithme retourne (None, None)

Si (returnDict = False) : 
    dict :
        "method" (str) : algorithm utilise.
        "optimization" (str) : minimisation ou maximisation.
        "success" (bool) : True si l'algorithm a converge.
        "x" (array or None) : Solution ou None si success = False.
        "f" (array or None) : Minimum ou None si success = False.
</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="minimization.minimize_scalar" href="#minimization.minimize_scalar">minimize_scalar</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="minimization.realBiObjective_NSGA2" href="#minimization.realBiObjective_NSGA2">realBiObjective_NSGA2</a></code></h4>
<ul class="">
<li><code><a title="minimization.realBiObjective_NSGA2.define_initial_population" href="#minimization.realBiObjective_NSGA2.define_initial_population">define_initial_population</a></code></li>
<li><code><a title="minimization.realBiObjective_NSGA2.getConstraintViolation" href="#minimization.realBiObjective_NSGA2.getConstraintViolation">getConstraintViolation</a></code></li>
<li><code><a title="minimization.realBiObjective_NSGA2.getLastPopulation" href="#minimization.realBiObjective_NSGA2.getLastPopulation">getLastPopulation</a></code></li>
<li><code><a title="minimization.realBiObjective_NSGA2.optimize" href="#minimization.realBiObjective_NSGA2.optimize">optimize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="minimization.realSingleObjectiveGA" href="#minimization.realSingleObjectiveGA">realSingleObjectiveGA</a></code></h4>
<ul class="">
<li><code><a title="minimization.realSingleObjectiveGA.define_initial_population" href="#minimization.realSingleObjectiveGA.define_initial_population">define_initial_population</a></code></li>
<li><code><a title="minimization.realSingleObjectiveGA.getLastPopulation" href="#minimization.realSingleObjectiveGA.getLastPopulation">getLastPopulation</a></code></li>
<li><code><a title="minimization.realSingleObjectiveGA.getStatOptimisation" href="#minimization.realSingleObjectiveGA.getStatOptimisation">getStatOptimisation</a></code></li>
<li><code><a title="minimization.realSingleObjectiveGA.maximize" href="#minimization.realSingleObjectiveGA.maximize">maximize</a></code></li>
<li><code><a title="minimization.realSingleObjectiveGA.minimize" href="#minimization.realSingleObjectiveGA.minimize">minimize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>